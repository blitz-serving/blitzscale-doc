<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Disaggregation(TODO) - blitzscale-doc</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../../favicon.svg">
        <link rel="shortcut icon" href="../../favicon.png">
        <link rel="stylesheet" href="../../css/variables.css">
        <link rel="stylesheet" href="../../css/general.css">
        <link rel="stylesheet" href="../../css/chrome.css">
        <link rel="stylesheet" href="../../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="../../highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="../../tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="../../ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "../../";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../../toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">blitzscale-doc</h1>

                    <div class="right-buttons">
                        <a href="../../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/blitz-serving/blitzscale-doc" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="disaggregation"><a class="header" href="#disaggregation">Disaggregation</a></h1>
<h2 id="请求处理"><a class="header" href="#请求处理">请求处理</a></h2>
<p><code>start_disaggregation_event_loop</code>函数创建loop处理不同逻辑的Task
创建steersman记录每个replica的物理所在位置，spawn_migration_queue,并对每个replica spawn出disaggregation_event_loop_inner，以状态机的实现方式，向对应的replica发送请求，以及根据replica的状态进行请求的传递(zigzag/pd migration)。
之后，创建DisaggregationController,进行reject_kv_cache_event_loop(避免decode实例过载)和report_system_metrics
不指定manually_scale编译选项时spawn出auto_scale_event_loop进行自动扩容()</p>
<h3 id="auto_scale_event_loop"><a class="header" href="#auto_scale_event_loop">auto_scale_event_loop</a></h3>
<p>在planner的replica_state_moniter_loop中
循环generate_scale_target,并判断当前扩缩容feature，对于blitz使用exec_blitz中的扩缩容方案，sllm使用exec_serverless中的方案。
exec_serverless直接向实例发送请求，从hostmem或者disk中加载参数
而exec_blitz则使用RDMA p2p, NVLink p2p， NVLink broadcast或Tanz等方式进行扩容</p>
<h3 id="reject_kv_cache_event_loop"><a class="header" href="#reject_kv_cache_event_loop">reject_kv_cache_event_loop</a></h3>
<p>动态检测并锁定某些decode副本，防止继续接收kvcache请求。
遍历所有副本，并记录处于decode或Rdmasending状态副本的used_blocks。之后如果发现有decode使用的blocks高于平均值的两倍，则锁定该副本。
实际执行上会与上次锁定的副本进行比较，只锁定新增的副本。</p>
<h3 id="report_network_flow"><a class="header" href="#report_network_flow">report_network_flow</a></h3>
<p>收集每个replica的flow_in和flow_out，构建flow_map用来打印日志</p>
<h3 id="report_system_metrics"><a class="header" href="#report_system_metrics">report_system_metrics</a></h3>
<p>遍历每个replica_metric，打印state，used_blocks以及是否加载模型等信息</p>
<h3 id="report_cur_waiting_prefill_tokens"><a class="header" href="#report_cur_waiting_prefill_tokens">report_cur_waiting_prefill_tokens</a></h3>
<p>当前deprecated</p>
<h3 id="disaggregation_event_loop_inner"><a class="header" href="#disaggregation_event_loop_inner">disaggregation_event_loop_inner</a></h3>
<p>核心循环，以状态机的方式实现对不同replica状态的逻辑，包括batch发送，请求migration等逻辑。对于每个replica，都创建出处理当前replica的event_loop。传入参数如下</p>
<ol>
<li>用于同步的init_guard</li>
<li>状态切换命令的ReplicaCommand Channel</li>
<li>queue</li>
<li>migration queue</li>
<li>replica_metric</li>
</ol>
<p>在循环中每次取出当前replica状态，尝试接收Command并根据状态执行不同的处理逻辑。没有接收到Command就直接使用当前状态</p>
<h4 id="inactiveloadingprefillloadingdecode"><a class="header" href="#inactiveloadingprefillloadingdecode">inactive/loadingprefill/loadingdecode</a></h4>
<p>yield等待</p>
<h4 id="shuttingnull"><a class="header" href="#shuttingnull">shuttingnull</a></h4>
<p>将当前replica上锁，避免被其他进程操作。
yield等待</p>
<h4 id="decode"><a class="header" href="#decode">decode</a></h4>
<p>循环从migration_queue中try_consume batch(tokens batch entries)并压入global_batch。如果global_batch已经为空则yield释放，否则进行一次Decode
包括对系统metric进行设置，将batch和last_token通过stub发送给后端(decode_v2)，将generations通过stream sender发送给等待向流式请求返回响应的线程。如果是最后一个token返回InferStreamResponse::End,否则返回InferStreamResponse::Intermediate，接收者会进行不同的处理。当前loop会在请求生成最后一个token时从entries中移除该请求。之后将结束的请求向server发送clear_cache,未结束的请求发送filter_batch并重新放入global_batch，进行下一轮处理</p>
<h4 id="prefill"><a class="header" href="#prefill">prefill</a></h4>
<p>如果当前需求的block已经大于每个replica最大的block数，则yield
否则从queue中调用next_batch得到下一个prefill batch，增加使用的blocks计数，构造PrefillCase::Normal的prefillRequest，调用stub.prefill_v2得到prefill的Response，发送InferStreamResponse::PrefillDone &amp; InferStreamReponse::Intermediate | InferStreamResponse::End,并判断client是否quit，如果由于client quit或Response::End则从entries中移除，并根据移除情况进行clear_cache / filter_batch
由于是PD分离，将Prefill的结果构造为MigrationBatch，通过flow_watcher和migration_queue进行传递(batch entries tokens),交由Decode实例进行Decode阶段</p>
<h4 id="newprefill"><a class="header" href="#newprefill">newprefill</a></h4>
<p>用于ZigZag执行的前半段，确保当前replica持有锁
初始化zig_zag相关的时间戳并检查模型是否已经加载
模型已加载则从pending_zag_prefill队列头部取出batch和前半段prefill的response，执行post_prefill_pre_decode。然后create_refact_head_task创建任务(循环从pending_zag_prefill请求中取出等待，并将将结果进行filter和send)，切换到RefactoryPrefill状态，进入下一轮循环
如果当前replica使用的block已经超上限，则yield进入下一轮循环
如果模型未加载完毕，则从Relay_queue中尝试取出relay请求，向所有stub发送relay请求等待response(将完成的前半段请求传递给old prefill)。
如果response中包含batch_id和seq_num，则循环从pending_zag_prefill中pop。如果pop出的prefill response start_layer为空则post_prefill_pre_decode，并修改model_loaded为true，否则break循环。此时已经得到start_layer非空的request，根据start_layer类型，transformerlayer部分迁移，向migration_queue append_partial_fst，之后通过sender通知OldPrefill(forwardcase为naivepp和immigrate)。embeddinglayer则直接迁移，同样sender通知OldPrefill(forwardcase为normal)并通知所有stub clear_cache
如果response中不包含batch_id和seq_num,则重新判断model_loaded。如果model_loaded被置为true</p>
<p>之后判断pending_zag_prefill的长度并yield控制zigzag速率
从batching_queue中获取下一个batch并发起新的zigzagprefill，压入pending_zag_prefill队列等待后续处理</p>
<h4 id="refactoryprefill"><a class="header" href="#refactoryprefill">refactoryprefill</a></h4>
<p>这个状态用于批量处理pending_zag_prefill队列中的任务，在relay_queue中检查relay请求，如果有则进入relay处理流程
relay处理流程首先向所有stub调用relay操作(传入relay_rank)，如果response中包含了batch_id和seq_num，则说明有batch需要迁移，取出pending_zag_prefill中对应的future，等待完成之后判断response的start_layer，根据transformer和embedding进行NewPrefill中同样的处理。
如果response不包含batch_id，说明迁移已经完成，统计pending_zag_prefill并进行异常检查，通过sender通知OldPrefill，等待refactory_head_task结束之后重置状态为Prefill</p>
<h4 id="oldprefill"><a class="header" href="#oldprefill">oldprefill</a></h4>
<p>用于ZigZag执行的后半段
调用全局relay_queue的append，在这里通过async_channel_sender发送请求(indices: 当前所在PP rank)，等待收到PartialPrefill请求。
收到partialprefill请求后调用prefill_v2并执行filter、send逻辑。
如果请求的start_layer是TransformerLayer，则PartialMigration(append_partial_snd，因为前半段prefill也有kvcache需要migration)，指定层级迁移部分kvcache；如果是EmbeddingLayer则append迁移整个batch的kvcache，因为此时当前replica保有全部的kvcache
这两者的不同会在spawn_migration_queue中进行分别处理。
如果在relay_queue中没有拿到partialprefill请求，则等待relay_cnt归零将状态切换为Prefill</p>
<h4 id="mutatingtodecode"><a class="header" href="#mutatingtodecode">mutatingtodecode</a></h4>
<p>向Migration_queue发送Flush命令，将所有属于当前replica未迁移的batch一次性取出，放入global_entries和global_batches，供decode后续使用。
之后状态切换为Decode</p>
<h4 id="auspreflil"><a class="header" href="#auspreflil">auspreflil</a></h4>
<p>持锁之后转变为prefill</p>
<h4 id="ausdecode"><a class="header" href="#ausdecode">ausdecode</a></h4>
<p>持锁之后转变为decode</p>
<h4 id="shuttingdecode"><a class="header" href="#shuttingdecode">shuttingdecode</a></h4>
<p>decode状态切换到彻底关闭的清理状态，目的是完成所有剩余的decode任务。如果global_batches为空并且持有锁则切换到shuttingNull
如果还没有持有锁，则尝试异步获取锁防止并发冲突(或yield等待join_handle结束持锁)
获取到锁之后不断从migration_queue中消费属于本副本的migration_queue,并循环从global_batches中取出request进行decode，同样对每轮生成filter_send_generations，直到global_batches被清空</p>
<h4 id="shuttingprefill"><a class="header" href="#shuttingprefill">shuttingprefill</a></h4>
<p>当unfinished_migration_count归零时切换到ShuttingNull，否则yield等待
unfinished_migration_count会在向migration_queue中压入batch时increment</p>
<h4 id="sendingloadingcasting"><a class="header" href="#sendingloadingcasting">sending/loading/casting</a></h4>
<p>panic</p>
<h2 id="扩缩容"><a class="header" href="#扩缩容">扩缩容</a></h2>
<p>通过状态机进行状态的切换</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../../components/router.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../../components/router/exec_blitz.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../../components/router.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../../components/router/exec_blitz.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <!-- Livereload script (if served using the cli tool) -->
        <script>
            const wsProtocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsAddress = wsProtocol + "//" + location.host + "/" + "__livereload";
            const socket = new WebSocket(wsAddress);
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>



        <script>
            window.playground_copyable = true;
        </script>


        <script src="../../elasticlunr.min.js"></script>
        <script src="../../mark.min.js"></script>
        <script src="../../searcher.js"></script>

        <script src="../../clipboard.min.js"></script>
        <script src="../../highlight.js"></script>
        <script src="../../book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
